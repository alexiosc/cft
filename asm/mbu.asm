;;; -*- cftasm -*-
;;; 
;;; Definitions for the 2019 edition MBU (Memory Banking Unit).
;;;
;;; The MBU extends the 16-bit address space of the CFT by 8 bits using eight
;;; 8-bit Memory Bank Registers, MBRs named MB0 to MB7. A 24-bit address is
;;; generated by picking one of the MBRs and ORring it with a 16 bit
;;; address. These aren't Intel segment registers, and no addition takes
;;; place. The formula is simply: (MBR << 16) | ADDR.
;;; 
;;; The first four MBRs have special semantics to the instruction set, but
;;; otherwise all eight are the same:
;;;
;;; Register  AKA  Addr   Used for
;;; -----------------------------------------------------------------------------
;;; MB0       MBP  &008   All instruction fetches, local page data fetches
;;; MB1       MBD  &009   Indirect data fetches not indexed by another MBR
;;; MB2       MBS  &00a   The hardware stack
;;; MB3       MBZ  &00b   The Memory Bank of Page Zero.
;;; MB4            &00c   For user programs.
;;; MB5            &00d   For user programs.
;;; MB6            &00e   For user programs.
;;; MB7            &00f   For user programs.
;;;
;;; After reset, the MBU will always generate addresses like &00:xxxx. if the
;;; RAM/ROM switch on the front panel is in the RAM position. This selects RAM
;;; and the computer can be programmed from the front panel.
;;;
;;; If the switch is in the ROM position, the MBU generates addresses like
;;; &80:xxxx and ROM is accessed initially. Any ROM bootstrap's first order of
;;; business is thus to program MBP to point to itself, MBD, MBS and MBZ point
;;; to RAM because subroutines, interrupts and autoindexing require RAM.
;;;
;;; It's necessary to initialise even MBP because once the MBU is enabled, the
;;; heretofore uninitialised registers will have garbage in them. It's
;;; impossible to disable the MBU once enabled.
;;;
;;; The device is read/write. Extended instructions SMB and RMB are provided to
;;; write to and read specific MBRs. They each take a number 0-7 (the number of
;;; the MBR to access) as argument.


.equ SMB   OUT       mbu.BASE		; SMB extended instruction
.equ RMB   IN        mbu.BASE		; RMB extended instruction

.pushns mbu

;;; Useful macros. You probably won't have to use anything other than these, ISR
;;; and ISR_IRQn for testing if an interrupt has been signaled.

;;; Map memory. Bank is the bank register to access (0-7). Phys is the physical
;;; page to map to that register.


;;; ;;; Definitions

.equ BASE R &008			; Base address

.equ MB0  0
.equ MB1  1
.equ MB2  2
.equ MB3  3
.equ MB4  4
.equ MB5  5
.equ MB6  6
.equ MB7  7
		
.equ MBP  MB0
.equ MBD  MB1
.equ MBS  MB2
.equ MBZ  MB3

.popns mbu

;;; End of file.
