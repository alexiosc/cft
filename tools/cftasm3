#!/usr/bin/env python3
# coding: utf-8
# -*- python -*-
"""
The CFT Assembler, version 3
"""

import os
import re
import sys
import copy
import types
import array
import pprint
import doctest
import optparse
import subprocess
import unicodedata

# TODO for 2019 compatibility:
#
# [X] Add builtins for new instruction set.
# [X] Complete Python 3 compatibility.
# [ ] Switch to using 24-bit addresses, OR
# [ ] Add a linker to put together banks into a single large program.

# Microcode 6 instruction set, the old one.
_BUILTINS_OLD = """;;; CFT Assembler Built-ins

;;; 1. Machine mnemonics

;;; 1.1. Basic mnemonics

.equ TRAP  0x0000
.equ IOT   0x1000
.equ LOAD  0x2000
.equ STORE 0x3000
.equ IN    0x4000
.equ OUT   0x5000
.equ JMP   0x6000
.equ JSR   0x7000
.equ ADD   0x8000
.equ AND   0x9000
.equ OR    0xA000
.equ XOR   0xB000
.equ OP1   0xC000
.equ OP2   0xD000
.equ POP   0xD800               // POP = OP2 I
.equ ISZ   0xE000
.equ LIA   0xF000
.equ JMPII 0xF800

;;; 1.1.1. Instruction flags.

.equ R     0x0400 ; Specify to reference a register (zero page).
.equ I     0x0800 ; Indirection


;;; 2. OP1 Mnemonics, in order of execution.

.equ IFL OP1  #1---------		; Execute the rest only if L is set.
.equ IFV OP1  #-1--------		; Execute the rest only if V is set.
.equ CLA OP1  #--1-------		; AC <- 0
.equ CLL OP1  #---1------		; L <- 0
.equ NOT OP1  #----1-----		; AC <- NOT A
.equ INC OP1  #-----1----		; <L,AC> <- <L,AC> + 1
.equ CPL OP1  #------1---		; L <- NOT L
.equ RBL OP1  #-------010		; <L,AC> <- <L,AC> >> 1
.equ RBR OP1  #-------001		; <L,AC> <- <L,AC> << 1
.equ RNL OP1  #-------110		; <L,AC> <- <L,AC> >> 4
.equ RNR OP1  #-------101		; <L,AC> <- <L,AC> << 4


;;; 3. OP2 Mnemonics, in order of execution.

.equ NOP  OP2 #-----00000		; (no semantics)
.equ SNA  OP2 #-----01---		; AC & 0x8000 == 1 ==> PC := PC + 1  }
.equ SZA  OP2 #-----0-1--		; AC == 0 ==> PC := PC + 1           } ORred together
.equ SSL  OP2 #-----0--1-		; L == 1 ==> PC := PC + 1            }
.equ SSV  OP2 #-----0---1		; V == 1 ==> PC := PC + 1            }
.equ SKIP OP2 #-----10000		; PC := PC + 1
.equ SNN  OP2 #-----11---		; AC & 0x8000 == 0 ==> PC := PC + 1  }
.equ SNZ  OP2 #-----1-1--		; AC != 0 ==> PC := PC + 1           } ANDed together
.equ SCL  OP2 #-----1--1-		; L == 0 ==> PC := PC + 1            }
.equ SCV  OP2 #-----1---1		; V == 0 ==> PC := PC + 1            }
;.equ CLA OP2 #--1-------		; AC <- 0
.equ CLI  OP2 #---1------		; INT <= 0
.equ SEI  OP2 #----1-----		; INT <= 1


;;; 4. Common macros

.equ SEL CLL CPL                        ; Set L
.equ NEG NOT INC			; Negate AC, in two's complement.
.equ ING NOT			        ; AC = -(AC+1) Increment and negate A, in two's complement
.equ LI    LIA R                        ; Load immediate (0 to &3ff)
.equ SPA SNN SNZ			; Skip on positive AC
.equ SNP SNA SZA                        ; Skip on non-positive AC

.equ IFNN SNA                           ; (don't skip) if AC >= 0
.equ IFPA SNA SZA                       ; (don't skip) if AC > 0
.equ IFNZ SZA                           ; (don't skip) if AC != 0
.equ IFZA SNZ                           ; (don't skip) if AC == 0
.equ IFNA SNN                           ; (don't skip) if AC < 0
.equ IFNP SNN SNZ                       ; (don't skip) if AC <= 0

.equ RET JMP I R 0                      ; Return from a subroutine
.equ RTT JMP I R 1                      ; Return from a trap
.equ RTI JMP I R 2                      ; Return from the ISR

.equ SBL CLL RBL                        ; Shift bit left
.equ SBR CLL RBR                        ; Shift bit right

.equ PUSH STORE I                       ; To mirror POP in Microcode v6 (autoinc only)


"""


# Microcode 7 instruction set. This is the current one, with Memory Bank
# Registers and a Stack Pointer.
_BUILTINS = """;;; CFT Assembler Built-ins, Microcode Version 7.x.

;;; Native Instruction Mnemonics

.equ    IRET    &0000            ; 0000:0:0:000:-------  Interrupt Return
.equ    LRET    &0080            ; 0000:0:0:001:-------  Long Return
.equ    RET     &0100            ; 0000:0:0:010:-------  Return
.equ    TAS     &0180            ; 0000:0:0:011:-------  Transfer Accumulator to Stack Pointer
.equ    TSA     &0200            ; 0000:0:0:100:-------  Transfer Stack Pointer to Accumulator
.equ    TAD     &0280            ; 0000:0:0:101:-------  Transfer Accumulator to Data Register
.equ    TDA     &0300            ; 0000:0:0:110:-------  Transfer Data Register to Accumulator
.equ    ISR     &0400            ; 0000:0:1:000:LLLLLLL  Software Interrupt
.equ    PHA     &0480            ; 0000:0:1:001:-------  Push Accumulator
.equ    PPA     &0500            ; 0000:0:1:010:-------  Pop Accumulator
.equ    PHF     &0580            ; 0000:0:1:011:-------  Push Flags
.equ    PPF     &0600            ; 0000:0:1:100:-------  Pop Flags
.equ    STI     &0680            ; 0000:0:1:101:-------  Set Interrupt Flag
.equ    CLI     &0700            ; 0000:0:1:110:-------  Clear Interrupt Flag
.equ    WAIT    &0780            ; 0000:0:1:111:LLLLLLL  Wait for Interrupt
.equ    SHL     &0800            ; 0000:1:0:000:000LLLL  Bitwise Shift Left
.equ    SHR     &0810            ; 0000:1:0:000:001LLLL  Bitwise Shift Right
.equ    ASR     &0830            ; 0000:1:0:000:011LLLL  Arithmetic Shift Right
.equ    ROL     &0840            ; 0000:1:0:000:100LLLL  Roll Left
.equ    ROR     &0850            ; 0000:1:0:000:101LLLL  Roll Right
.equ    RLA     &0860            ; 0000:1:0:000:110LLLL  Roll Left Accumulator
.equ    RRA     &0870            ; 0000:1:0:000:111LLLL  Roll Right Accumulator

.equ    SKP     &0880            ; SKP bitmap instruction
.equ    NOP     SKP     #0000000 ; 0000:1:0:001:0000000  No Operation
.equ    SKIP    SKP     #0010000 ; 0000:1:0:001:--10000  Skip
.equ    SNP     SKP     #0001100 ; 0000:1:0:001:--011--  Skip on Non-Positive Accumulator
.equ    SPA     SKP     #0011100 ; 0000:1:0:001:--111--  Skip on Positive Accumulator
.equ    SNA     SKP     #0001000 ; 0000:1:0:001:--01---  Skip on Negative Accumulator
.equ    SZA     SKP     #0000100 ; 0000:1:0:001:--0-1--  Skip on Zero Accumulator
.equ    SSL     SKP     #0000010 ; 0000:1:0:001:--0--1-  Skip on Link
.equ    SSV     SKP     #0000001 ; 0000:1:0:001:--0---1  Skip on Overflow
.equ    SNN     SKP     #0011000 ; 0000:1:0:001:--11---  Skip on Non-Negative Accumulator
.equ    SNZ     SKP     #0010100 ; 0000:1:0:001:--1-1--  Skip on Non-Zero Accumulator
.equ    SCL     SKP     #0010010 ; 0000:1:0:001:--1--1-  Skip on Link Clear
.equ    SCV     SKP     #0010001 ; 0000:1:0:001:--1---1  Skip on Overflow

.equ    IND     &0b80            ; 0000:1:0:111:-------  Indirect
.equ    JPA     &0c00            ; 0000:1:1:000:-------  Jump to Accumulator
.equ    JSA     &0c80            ; 0000:1:1:001:-------  Jump to Subroutine at Accumulator
.equ    HCF     &0d80            ; 0000:1:1:011:-------  Halt and Catch Fire

; Note: the sub-instructions here can be used either with UOP (in which case
; the UOP mnemonic can be left out) or with either the IFL or IFV bitmap
; instructions. IFL and IFV must be specified.

.equ    UOP     &0e00            ; UOP bitmap instruction
.equ    IFL     &0e8c            ; IFL bitmap instruction
.equ    IFV     &0f0c            ; IFV bitmap instruction
.equ    NOP9    UOP     #0000000 ; 0000:1:1:100:0000000  No Operation, 9 Cycles
.equ    CLA     UOP     #0100000 ; 0000:1:1:100:-1-----  Clear Accumulator
.equ    CLL     UOP     #0010000 ; 0000:1:1:100:--1----  Clear Link
.equ    SEL     UOP     #0000001 ; 0000:1:1:100:--1---1  Set Link
.equ    NOT     UOP     #0001000 ; 0000:1:1:100:---1---  Complement Accumulator
.equ    NEG     UOP     #0001100 ; 0000:1:1:100:---11--  Negate Accumulator
.equ    INC     UOP     #0000100 ; 0000:1:1:100:----1--  Increment Accumulator
.equ    DEC     UOP     #0000010 ; 0000:1:1:100:-----1-  Decrement Accumulator
.equ    CPL     UOP     #0000001 ; 0000:1:1:100:------1  Complement Link

.equ    LIA     &1000            ; 0001:I:R:mmmmmmmmmm   Literal Address
.equ    LI      &1400            ; 0001:0:1:LLLLLLLLLL   Literal
.equ    LJSR    &1800            ; 0001:1:R:aaaaaaaaaa   Long Jump to Subroutine
.equ    LJMP    &2800            ; 0010:1:R:aaaaaaaaaa   Long Jump
.equ    JSR     &3000            ; 0011:I:R:mmmmmmmmmm   Jump to Subroutine
.equ    JMP     &4000            ; 0100:I:R:mmmmmmmmmm   Jump
.equ    IN      &5000            ; 0101:I:R:mmmmmmmmmm   Input from I/O Space
.equ    OUT     &6000            ; 0110:I:R:mmmmmmmmmm   Output to I/O Space
.equ    IOT     &7000            ; 0111:I:R:mmmmmmmmmm   I/O Transaction
.equ    LOAD    &8000            ; 1000:I:R:mmmmmmmmmm   Load Accumulator
.equ    STORE   &9000            ; 1001:I:R:mmmmmmmmmm   Store Accumulator
.equ    DSZ     &a000            ; 1010:I:R:mmmmmmmmmm   Decrement and Skip if Zero
.equ    ADD     &c000            ; 1100:I:R:mmmmmmmmmm   Add To Accumulator
.equ    AND     &d000            ; 1101:I:R:mmmmmmmmmm   Bitwise AND With Accumulator
.equ    OR      &e000            ; 1110:I:R:mmmmmmmmmm   Bitwise OR With Accumulator
.equ    XOR     &f000            ; 1111:I:R:mmmmmmmmmm   Bitwise XOR With Accumulator

;;; Instruction flags. These only make sense for instructions with I or R in
;;; their bitfields.

.equ    R       &0400            ; Zero Page ('register') reference
.equ    I       &0800            ; Indirection

;;; End of file.
"""


XPMHEAD = """/* XPM */
static char * cfg_mem_xpm[] = {
  "256 256 8 1",
  "  c #222222",
  "I c #FF5555",
  "S c #55FF55",
  "C c #55FF55",
  "s c #FFA555",
  "F c #55FFFF"
  "W c #4433FF",
  "P c #000000",
  "R c #FF55FF",
"""

XPMFOOT = """};

/* End of file */
"""


def isprint(c, encoding=None):
    """Return True if the specified character is printable (by a rather naive
    set of criteria). Can be unicode."""
    if ord(c) < 32 or ord(c) > 127:
        return False
    cat = unicodedata.category(c.decode(encoding or 'utf-8'))
    return cat[0] in ['L', 'N', 'P', 'S', 'Z']


class Symbol(object):
    """A symbol table symbol."""
    def __init__(self, name, val, filename, linenum):
        self.name = name
        self.val = val
        self.filename = filename
        self.linenum = linenum

    def __str__(self):
        return '<%s %s = %04x>' % (self.__class__.__name__, self.name, self.val)


    @property
    def page(self):
        """Provide the middle 6 bits of the value."""
        return self.val & 0xfc00


    @property
    def offset(self):
        """Provide the lower 10 bits of the value."""
        return self.val & 0x03ff


    @property
    def assembly_val(self):
        """Provide a field for instruction assembly. For non-labels
        (i.e. instructions, EQUs, etc), we return the whole word."""
        return self.val


    def inaccessible(self, addr):
        """Returns True if the value represents an address
        inaccessible from the current address due to them being on
        different pages.

        For non-label symbols, always return False. They don't
        necessarily represent addresses."""
        return False


class Label(Symbol):
    """A label in the symbol table. Labels are treated specially when they're
    used in an assembly instruction: only the offset may be used."""
    @property
    def assembly_val(self):
        """Only return the offset of this label, not the entire value."""
        return self.offset


    def inaccessible(self, addr):
        """Returns True if the value represents an address
        inaccessible from the current address due to them being on
        different pages."""
        return (addr & 0xfc00) != self.page


class Register(Label):
    """A label denoting a register defined with the .reg directive."""


class CFTAssembler(object):

    # The Assembler built-ins.
    BUILTINS = _BUILTINS

    # Pass numbers.
    PSN_MACRO_DISCOVERY = 0
    PSN_SYMBOL_DISCOVERY = 1
    PSN_ASSEMBLY = 2
    PSN_LAST_PASS = PSN_ASSEMBLY

    # All assembled instructions (not data) are XORred with this.
    R_FLAG = 0x0400
    I_FLAG = 0x0800

    #MEMSIZE = 65536
    MEMSIZE = 2 << 20           # Use entire address space

    # Default location of the C Preprocessor.
    CPP_LOCATION = '/usr/bin/cpp'

    
    def __init__(self):
        self.linenum = 1
        self.filename = '<none>'
        self.out = sys.stderr.write

        # Locate the C Preprocessor
        self.cpp = os.environ.get('CPP', self.CPP_LOCATION)

        # The symbol table.
        self.symbols = dict()

        # The namespace stack.
        self.ns = list()

        # The macro table and macro context stack
        self.macros = dict()
        self.ctx = list()
        self.mcallno = 0

        # Filename and line numbers.
        self.filename = '<none>'
        self.linenum = 1

        # The current address in memory.
        self.minaddr = self.MEMSIZE
        self.maxaddr = 0
        self.boundwarn_low = False
        self.boundwarn_high = False
        self.setaddr(0)

        # The memory image.
        self.mem = array.array('H')
        self.mem.fromlist([0x0000] * self.MEMSIZE)
        self.sentinel = array.array('b')
        self.sentinel.fromlist([32] * self.MEMSIZE)

        self.opts, self.args = self.parseOpts()

        # Update the various filenames.
        base = os.path.splitext(self.opts.out_file)[0]
        self.map_file = self.opts.map_file or (base + '.map')
        self.asm_file = self.opts.asm_file or (base + '.pasm')
        self.symbol_file = self.opts.symbol_file or (base + '.sym')
        self.xpm_map_file = self.opts.xpm or (base + '.xpm')

        # Create the processed assembly output file.
        self.pasm = open(self.asm_file, 'w')

        # State
        self.wrap = False
        self.jumped = False
        self.bank = None
        
        # Execute
        try:
            self.run()
        except IOError as e:
            self.die(str(e))


    def parseOpts(self):
        """Parse command-line options."""
        p = optparse.OptionParser()
        p.add_option('-a', '--asm-file',
                     help='Set processed assembly file output (default: OUTPUT-FILE.pasm).')
        p.add_option('-m', '--map-file',
                     help='Set map file output (default: OUTPUT-FILE.map).')
        p.add_option('-o', '--out-file', metavar='OUTPUT-FILE', default='a.bin',
                     help='Output object file to OUTPUT-FILE (default: a.bin).')
        p.add_option('-s', '--symbol-file',
                     help='Set symbol file output (default: OUTPUT-FILE.sym).')
        p.add_option('', '--xpm',
                     help='Output an XPM file mapping the memory image. ' + 
                     'This is merely a visualisation toy. (default: output nothing).')

        p.add_option('', '--no-builtins', action='store_true',
                     help='Start with no built-in symbols at all.')
        p.add_option('-v', '--verbose', action='store_true',
                     help='Print out assembled code')
        p.add_option('-d', '--debugging', action='store_true',
                     help='Print out parsed code and debugging info.')
        p.add_option('', '--show-builtins', action='store_true',
                     help='Print out built-ins and exit.')
        p.add_option('-I', '--include', metavar='PATH', action='append', default=[],
                     help='Set include path. Can be specified multiple times ' + \
                         '(paths in current directory always take precedence).')
        p.add_option('', '--min-addr', action='store', type='int', default=0x0000,
                     help='Set the starting address for dumping objects, verilog output ' + \
                         'et cetera (default: 0)')
        p.add_option('', '--max-addr', action='store', type='int', default=0xffff,
                     help='Set the ending address for dumping objects, verilog output ' + \
                         'et cetera (default: 65535)')
        p.add_option('-B', '--banked', action='store_true',
                     help='Assemble for extended 24-bit address space. All addresses are ' + \
                         'mod 8192, and you must use the .bank directive at least once.')
        
        return p.parse_args()


    def run(self):
        """Run the assembler."""

        # Check mode of operation and act on it.
        if self.opts.show_builtins:
            print(self.BUILTINS)
            sys.exit(0)

        # Sanity checking
        if self.opts.min_addr > self.opts.max_addr:
            self.die('--min-addr must be less than or equal to --max-addr.')
        
        # For everything else, we need a filename to assemble.
        if not self.args:
            self.die('an input file must be provided.')

        # Run the assembler.
        self.parse()

        # Output the object code.
        self.outobj()


    def parse(self):
        """Assemble the input files.

        We perform a two-pass assembly:
        
        * Pass 1: compile symbol table.
        * Pass 2: assemble code.
        """
        self.passnum = self.PSN_MACRO_DISCOVERY

        while True:
            #print "New pass", self.passnum

            # Clear the namespace stack
            self.ns = []
            self.deferred = []
            self.scope = 0
            self.longstring = None
            self.compstring = None
            
            # First, parse the builtins.
            self.filename = '<builtins>'
            self.linenum = 0
            self.setaddr(0)
            self.jumped = False
            self.assembly_pass(self.BUILTINS.split('\n'))

            # Then, parse each input file in order.
            for filename in self.args:
                self.filename = filename
                self.linenum = 0
                self.mcallno = 0

                self.assembly_pass(open(filename))

            # Warn about unbalanced namespaces
            if len(self.ns):
                self.warn("Namespace stack not empty at end of document (%s)" %
                          (', '.join(self.ns)))

            if self.deferred:
                print("Deferred symbols:", self.deferred)
                # Undefine any deferred symbols
                for sym in self.deferred:
                    print("deleting", sym)
                    try:
                        del self.symbols[sym]
                    except KeyError:
                        continue
                

            # Move on to the next pass. There can be multiple symbol discovery
            # passes, depending on whether there are deferred symbols (forward
            # definitions that couldn't be resolved in one pass).
            if self.passnum == self.PSN_MACRO_DISCOVERY:
                self.passnum = self.PSN_SYMBOL_DISCOVERY
            elif self.passnum == self.PSN_SYMBOL_DISCOVERY:
                if not self.deferred:
                    self.passnum = self.PSN_ASSEMBLY
                else:
                    print("Deferred symbols:", self.deferred)
            elif self.passnum == self.PSN_ASSEMBLY:
                # At the end of the last parse, print out the symbol table.
                self.outmap()
                self.outsym()
                self.outxpm()
                break


    def assembly_pass(self, stuff):
        """Perform a single pass of the assembler."""
    
        for line in stuff:
            orgline = line.rstrip().expandtabs()
            self.linenum += 1

            line = line.strip()

            # Strip blank lines.
            if not line:
                continue

            tokens = list(self.lexer(line))
            if self.opts.debugging:
                print("D: %s:%d: %04x %s" % (self.filename, self.linenum, self.addr,
                                         ', '.join('<%s>' % x for x in tokens)))

            # Hm, the line is all comments and white space.
            if not tokens:
                continue

            # Process address-less directives
            if tokens[0].startswith('.'):
                if tokens[0] == '.equ':
                    if len(tokens) < 2:
                        self.fail('Value expected after .equ')
                    # Allow forward definitions: don't parse the token unless it's the last pass.
                    # TODO: Verify this code and remove 'True or'.
                    val = self.parseField(tokens[2:], allbits=True)
                    # if self.passnum == self.PSN_ASSEMBLY:
                    #     val = self.parseField(tokens[2:], allbits=True)
                    #     #print self.passnum, tokens[1], hex(val)
                    # else:
                    #     print self.parseField(tokens[2:], allbits=True)
                    #     val = 0xbeef
                    #     print self.passnum, tokens[1], hex(val)
                    self.addSymbol(tokens[1], val)
                    continue
                elif tokens[0] == '.macro':
                    self.parseMacroDef(line, stuff)
                    continue
                elif tokens[0] == '.include':
                    self.includeFile(line)
                    continue
                elif tokens[0] == '.pushns':
                    self.pushNamespace(line)
                    continue
                elif tokens[0] == '.popns':
                    self.popNamespace(line)
                    continue
                elif tokens[0] == '.scope':
                    self.startScope(line)
                    continue
                elif tokens[0] == '.endscope':
                    self.endScope(line)
                    continue

            # Is there a label or address?
            if len(tokens) > 1 and tokens[1] == ':':
                label = tokens[0]
                try:
                    self.setaddr(self.parseInt(label))
                    tokens = tokens[2:]
                except ValueError:
                    # It's a label.
                    self.addSymbol(tokens[0], self.addr, symtype=Label)
                    tokens = tokens[2:]

            # We purposefully don't _continue_ after a successful label parse.
            # There may be an instruction on the same line as the label.


            # Is this a macro call? If so, it should be the only thing on a
            # line, and be invoked like macro() or macro(a,b,c,...).
            x = re.findall('^\s*([\w.]+)\s*\((.+)\)\s*$', ' '.join(tokens))
            if x:
                #print "assemble macro", x[0]
                self.assembleMacro(x[0])
                continue

            # It must be an instruction, then. Only assemble after the symbol
            # discovery pass, otherwise some labels won't be defined.
            if tokens:

                # Is this an address-ful directive?
                if tokens[0].startswith('.'):
                    self.assembleDataDirective(tokens, orgline)
                else:
                    self.assembleInstruction(tokens, orgline)

                # The address increases regardless of the pass number.
                #sys.stderr.write('+++INC+++\n')
                self.incaddr()


    def includeFile(self, line):
        """Include an .asm file."""
        try:
            fname = re.findall('^\.include\s+"(\S+?)"', line)[0]
        except (TypeError, IndexError):
            self.fail('syntax error parsing .include directive')

        fn = fname
        class FoundFile(Exception):
            pass

        try:
            for pathcomp in ['.'] + self.opts.include:
                fn = os.path.join(pathcomp, fname)
                if os.path.exists(fn):
                    raise FoundFile
            self.fail("File %s not found in include path .:%s" \
                          % (fname, ':'.join(self.opts.include)))
        except FoundFile:
            pass

        try:
            f = open(fn)
        except IOError as e:
            self.fail(str(e))

        # Parse the specified file.
        if self.opts.debugging:
            sys.stderr.write('D: %s:%d: include file %s (%s)\n' % \
                                 (self.filename, self.linenum, fname, fn))
        savedState = self.filename, self.linenum
        self.pushParseContext(fn, self.filename, self.linenum, None)
        self.filename = fn
        self.linenum = 1
        self.assembly_pass(f)
        self.popParseContext()
        self.filename, self.linenum = savedState
        if self.opts.debugging:
            sys.stderr.write('D: %s:%d: end of included file %s\n' % \
                                 (self.filename, self.linenum, fname))


    def parseMacroDef(self, line, stuff):
        """Parse a macro definition."""
        
        start = self.linenum

        # Parse the macro definition
        try:
            name, arglist = re.findall('^\.macro\s+(\w+)\s*\((.*?)\)\s*', line)[0]
            arglist = re.split('\s*,\s*', arglist)

        except (TypeError, IndexError):
            self.fail('syntax error parsing macro definition')

        macrodef = []
        for line in stuff:
            orgline = line.rstrip().expandtabs()
            self.linenum += 1

            if line.strip() == '.end':
                if self.passnum == self.PSN_MACRO_DISCOVERY:
                    try:
                        pf, pl = self.getMacro(name)[:2]
                        self.fail("macro '%s' previously defined in %s, line %d." % (name, pf, pl))
                    except KeyError:
                        # New macro. Store it.
                        nsname = '.'.join(self.ns + [name])
                        self.macros[nsname] = (self.filename, start, arglist, macrodef)
                        #print "Defined macro", nsname
                return
            macrodef.append(line)

        self.fail("Macro without .end (started on line %d)" % start)


    def pushParseContext(self, macro, filename, linenum, mdef):
        """Push a macro context onto the context stack.

        This is used for error reporting."""
        self.ctx.append((macro, filename, linenum, mdef))


    def popParseContext(self):
        """Pop a macro context from the context stack.

        This is used for error reporting."""
        try:
            return self.ctx.pop()
        except IndexError:
            self.die('Attempted pop from empty context stack.')


    def assembleMacro(self, match):
        """Assemble a macro call.

        Macro calls are assembled in all passes by temporarily reading input
        from the macro definition, not the current file.
        """
        name, arglist = match
        arglist = [x.strip() for x in re.split('\s*,\s*', arglist)]

        try:
            #print "Assembling macro", name
            mf, mln, mal, mdef = self.getMacro(name)
        except KeyError:
            self.fail("undefined macro '%s'" % name)

        if len(arglist) != len(mal):
            self.fail("macro '%s' expects exactly %d arguments" % (name, len(mal)))

        # Copy the macro definition, because we'll be making changes
        mdef_inst = copy.copy(mdef)

        # Add a unique serial number argument. Useful for namespacing labels.
        self.mcallno += 1
        for i, line in enumerate(mdef_inst):
            mdef_inst[i] = line.replace('%_', str(self.mcallno))

        # Replace placeholders with actual arguments
        for argname, argval in zip(mal, arglist):
            for i, line in enumerate(mdef_inst):
                # WARNING: this will mess up with args like %n and
                # %num.
                #mdef_inst[i] = line.replace('%' + argname, argval)
                mdef_inst[i] = re.sub(r'%{?' + argname + r'(}|\b)', argval, line)

        # Set us up to parse the macro definition.
        if self.opts.debugging:
            sys.stderr.write('D: %s:%d: execute macro %s, arglist: %s\n' % \
                                 (self.filename, self.linenum, name, ', '.join(arglist)))
        fn, nl = self.filename, self.linenum
        self.pushParseContext(name, self.filename, self.linenum, self.getMacro(name))
        self.filename = mf
        self.linenum = mln
        self.assembly_pass(mdef_inst)
        self.popParseContext()
        self.filename, self.linenum = fn, nl
        if self.opts.debugging:
            sys.stderr.write('D: %s:%d: end of macro %s, arglist: %s\n' % \
                                 (self.filename, self.linenum, name, ', '.join(arglist)))


    def assembleDataDirective(self, tokens, orgline):
        """Assemble a data directive.
        
        A data directive is anything that starts with a . (e.g. .word, .str)
        and includes data for the output file (as opposed to other directives,
        which modify the behaviour of the assembler.
        """
        if tokens[0] == '.word':
            self.jumped = False
            if self.passnum == self.PSN_ASSEMBLY:
                val = self.parseField(tokens[1:], allbits=True, pageboundary=False)
                self.poke(val, poketype='W')
                self.logasm(val, orgline=orgline)

        elif tokens[0] == '.reg':
            if len(tokens) < 2:
                self.fail('Value expected after .reg')
            # Allow forward definitions: don't parse the token unless it's the last pass.
            # TODO: Verify this code and remove 'True or'.
            if self.passnum == self.PSN_ASSEMBLY:
                val = self.parseField(tokens[2:], allbits=True)
                #print self.passnum, tokens[1], hex(val)
            else:
                val = 0xdead
                #print self.passnum, tokens[1], hex(val)
            self.addSymbol('$' + tokens[1], self.addr, symtype=Register)
            self.addSymbol(tokens[1], val)

            self.poke(0x0000, poketype='R')
            if self.passnum == self.PSN_ASSEMBLY:
                self.logasm(val, orgline=orgline)
        elif tokens[0] in ('.str', '.data'):
            self.assembleString(tokens, orgline)
        elif tokens[0] == '.strn':
            self.assembleString(tokens, orgline, neg=True)
        elif tokens[0] == '.strp':
            self.assemblePackedString(tokens, orgline)
        elif tokens[0] in ('.longstring', '.compstring'):
            self.compstring = tokens[0] == '.compstring'
            if self.longstring is not None:
                self.fail(".longstring inside another .longstring.")
            if self.passnum == self.PSN_ASSEMBLY:
                self.logasm(None, msg='', orgline=orgline)
            self.longstring = []
            if len(tokens) > 1:
                self.assemblePackedString(tokens, orgline)
            # The address won't be incremented yet.
            self.incaddr(-1)
        elif tokens[0] == '.endstring':
            if self.compstring:
                self.assembleCompString(tokens, orgline)
            else:
                self.assembleLongString(tokens, orgline)
        elif tokens[0] == '.fill':
            self.assembleFill(tokens, orgline)
        elif tokens[0] == '.regfill':
            self.assembleFill(tokens, orgline, poketype='R')
        elif tokens[0] == '.page':
            self.assemblePage(tokens, orgline)
        elif tokens[0] == '.bank':
            self.assembleBank(tokens, orgline)
        elif tokens[0].startswith('.'):
            self.fail("Unknown assembler directive '%s'." % tokens[0])


    def assembleString(self, tokens, orgline, neg=False):
        """Assemble a string directive.

        A string directive places each value specified as a token in
        memory. Values can be strings enclosed in double-quotes or symbols,
        e.g.:

        .str "Hello, world!" 0   ; A null-terminated string.
        """
        if self.passnum == self.PSN_ASSEMBLY:
            self.logasm(None, msg='', orgline=orgline)
            #print 'A: %04x:      ; %s' % (self.addr, orgline)

        tokens = tokens[1:]
        for i, token in enumerate(tokens):
            if token.startswith('"'):
                # The lexer guarantees strings are enclosed in double
                # quotes. Strip them.
                chars = token[1:-1]
            else:
                # If it's not a string token, it should parse to an integer of sorts.
                chars = [self.parseToken(token)]

            for j, char in enumerate(chars):
                # Convert it to an int. Try numerous things.
                if type(char) == bytes:
                    val = ord(char)
                elif type(char) == str:
                    val = ord(char)
                elif type(char) == int:
                    val = char
                    char = chr(val)
                elif isinstance(char, Symbol):
                    val = char.assembly_val
                    char = chr(val)
                else:
                    self.fail('string/data element has weird type %s' % type(char))
                    
                if self.passnum == self.PSN_ASSEMBLY:
                    char = isprint(char) and char or ' '

                    # If this is the last character of the last token, and
                    # we're storing negative-terminated strings, OR the value
                    # with 0x8000.
                    if neg and ((i + 1) == len(tokens)) and ((j + 1) == len(chars)):
                        val |= 0x8000
                        self.logasm(val, orgline='"%s" (U+%04x) | 0x8000' % (char, val))
                    else:
                        self.logasm(val, orgline='"%s" (U+%04x)' % (char, val))

                self.poke(val, poketype='S')
                self.incaddr()

        # Our caller will increment the address, so adjust here.
        self.incaddr(-1)


    def assembleLongString(self, tokens, orgline):
        """Assemble the previously gathered tokens of a long string."""
        if self.longstring is None:
            self.fail(".endstring without matching .longstring!")
            return

        tokens = [ '.strp' ] + self.longstring + ['0']
        #print "*** TOKENS:", tokens
        self.longstring = None
        self.assemblePackedString(tokens, orgline)


    def assembleCompString(self, tokens, orgline, null=True):
        """Assemble a run-length, VDU-style packed string (.compstring
        directive).

        A compressed string stores byte values, one byte per word,
        with an off-by-one repetition count in the high-order
        bits. For instance, a value of &0041 decompresses to 'A'. A
        value of &0242 decompresses to 'CCC'. The repetition count is
        purposefully compatible to the VDU's CRR register.

        The string is null-terminated with a word value &0000 unless
        the optional argument null=False is provided.
        """
        raise RuntimeError('Not fully implemented yet')
        print(tokens)
        if self.passnum == self.PSN_ASSEMBLY:
            self.logasm(None, msg='', orgline=orgline)
            #print 'A: %04x:      ; %s' % (self.addr, orgline)

        tokens = tokens[1:]
        state = (0, None)

        def _storeChar(byteVal, state):
            if state[1] == byteVal and state[1] <= 256:
                state = (state[0] + 1, state[1])
            else:
                if state[1] is not None:
                    if self.passnum == self.PSN_ASSEMBLY:
                        val = ((state[0] - 1) << 8) | (state[1] & 0xff)
                        if state[0] < 40 and isprint(chr(state[1])):
                            s = '"%s"' % (chr(state[1]) * state[0])
                        else:
                            s = '"."'
                        self.logasm(val, orgline='%s %(U+%04x) x %d' % (s, state[1], state[0]))
                    self.poke(val, poketype='C')
                    self.incaddr()
                state = (1, byteVal)

            return state

        for i, token in enumerate(tokens):
            print(i, token)
            if token.startswith('"'):
                # The lexer guarantees strings are enclosed in double
                # quotes. Strip them.
                chars = token[1:-1]
            else:
                # If it's not a string token, it should parse to an integer of sorts.
                chars = [self.parseToken(token)]

            for j, char in enumerate(chars):
                try:
                    val = ord(char)
                except TypeError:
                    # It's already an int.
                    val = char
                state = _storeChar(val, state)

        if null:
            _storeChar(0, state)
        # Our caller will increment the address, so adjust here.
        self.incaddr(-1)

    def assemblePackedString(self, tokens, orgline):
        """Assemble a packed null-terminated string directive.

        A packed string is a string in which 8-bit bytes are
        word-packed. Even characters of a string (including the first
        one) use the least significant 8 bits of a word. Odd
        characters use the most significant 8 bits.

        The string is terminated by the bit sequence 00000000. The
        user is responsible for including this! Use something like:

        .strp "Spam, spam, spam and spam." 0

        where the last '0' is the string terminator.

        Packed strings can contain any byte-encoded character set
        (including Unicode, encoded in UTF-8 or UTF-7). Even-sized
        strings need an extra word for their terminating null.
        """
        if self.passnum == self.PSN_ASSEMBLY:
            self.logasm(None, msg='', orgline=orgline)
            #print 'A: %04x:      ; %s' % (self.addr, orgline)

        def _storechar(wordval):
            if self.passnum == self.PSN_ASSEMBLY:
                if wordval & 0x80:
                    self.logasm(wordval, orgline='"%s" (U+%04x) | 0x80' % \
                                    (chr(wordval & 0x7f), wordval & 0x7f))
                elif wordval & 0x8000:
                    self.logasm(wordval, orgline='"%s%s" (U+%04x U+%04x) | 0x8000' % \
                                    (chr(wordval & 0x7f), chr((wordval & 0x7f00) >> 8),
                                     wordval & 0x7f, (wordval & 0x7f00) >> 8))
                else:
                    self.logasm(wordval, orgline='"%s%s" (U+%04x U+%04x)' % \
                                    (chr(wordval & 0x7f), chr((wordval & 0x7f00) >> 8),
                                     wordval & 0x7f, (wordval & 0x7f00) >> 8))

            self.poke(wordval, poketype='s')
            self.incaddr()

        tokens = tokens[1:]
        numchars = 0
        wordval = 0
        #pprint.pprint(tokens)
        for i, token in enumerate(tokens):
            #if len(tokens) > 1:
            #    print "\t***", i, token.replace('\n', r'\n')

            # If we're in longstring mode, just gather all the tokens
            # for later processing.
            if self.longstring is not None:
                self.longstring.append(token)
                continue

            if token.startswith('"'):
                # The lexer guarantees strings are enclosed in double
                # quotes. Strip them.
                chars = token[1:-1]
            else:
                # If it's not a string token, it should parse to an integer of sorts.
                chars = [self.parseToken(token)]

            for j, char in enumerate(chars):
                try:
                    val = ord(char)
                except TypeError:
                    # It's already an int.
                    val = char
                    char = chr(char)
                    #if ord(char) not in xrange(128):
                    #    self.fail("Packed strings can only contain 7-bit characters.")
                if self.passnum == self.PSN_ASSEMBLY:
                    char = isprint(char) and char or ' '

                    # If this is the last character of the last token, set the
                    # high bit.
                    #if ((i + 1) == len(tokens)) and ((j + 1) == len(chars)):
                    #    val |= 0x80

                if (numchars & 1) == 0:
                    wordval = val
                else:
                    wordval = wordval | (val << 8)
                    _storechar(wordval)
                numchars += 1

        # There may be a leftover character when we're done.
        if (numchars & 1) != 0: # Note, numchars already increased: reverse semantics
            _storechar(val)

        # Our caller will increment the address, so adjust here.
        self.incaddr(-1)


    def assembleFill(self, tokens, orgline, poketype='F'):
        """Assemble a fill directive.

        Syntax: .fill COUNT WORD

        This will fill COUNT words starting at the current location with WORD,
        which can be any symbol that parses to a word (instruction, mnemonic,
        label, literal, etc).
        
        The COUNT must be a literal.
        """
        self.jumped = False
        try:
            count = self.parseInt(tokens[1])
        except Exception as e:
            self.fail(str(e))

        if self.passnum != self.PSN_ASSEMBLY:
            # We use count - 1 because the caller will increment the address
            # too.
            self.incaddr(count - 1)
            return
        
        # Assembly pass: do actual work.
        try:
            word = self.parseField(tokens[2:], allbits=True)
            try:
                word = word.val
            except AttributeError:
                pass
        except Exception as e:
            self.fail(str(e))

        self.logasm(None, msg=' .fill &%04x &%04x ; %s' % (count, word, orgline))

        for x in range(count):
            self.poke(word, poketype=poketype)
            self.incaddr()

        # Inhibit the next address increase.
        self.jumped = True


        
    def assemblePage(self, tokens, orgline):
        """Assemble a page directive.

        Syntax: .page [WORD]

        The .page directive automatically fills memory with WORD (which can be
        any parseable assembler expression, and defaults to zero) until the end
        of the current page is reached. This is useful for keeping code with
        relative addressing in the same memory area.

        Using .page allows code to run without rearranging during development.

        If more than 16 words are filled as a result of .page, a message is
        output during assembly. If more than 64 words are filled, a warning is
        output. If more than 128 words are filled, an error is raised.
        """
        self.jumped = False

        nextpage = (((self.addr >> 10) + 1) << 10)
        count = nextpage - self.addr

        # Already at the beginning of a page. Do nothing.
        if count == 0:
            return
        #elif count > 512:
        #    if self.passnum == self.PSN_ASSEMBLY:
        #        self.fail(".page generated %d words of slack space. Rearrange your code!" % count)
        elif count > 256:
            if self.passnum == self.PSN_ASSEMBLY:
                self.warn(".page generated %d words of slack space." % count)

        if self.passnum != self.PSN_ASSEMBLY:
            # We use count - 1 because the caller will increment the address
            # too.
            self.incaddr(count - 1)
            return
        
        # Assembly pass: do actual work.
        word = 0
        if len(tokens) >= 2:
            try:
                word = self.parseField(tokens[2:], allbits=True)
                try:
                    word = word.val
                except AttributeError:
                    pass
            except Exception as e:
                self.fail(str(e))

        self.logasm(None, msg=' .fill &%04x &%04x ; %s' % (count, word, orgline))

        for x in range(count):
            self.poke(word, poketype='P')
            self.incaddr()

        # Inhibit the next address increase.
        self.jumped = True


    def assembleBank(self, tokens, orgline):
        """Assemble a bank directive.

        Syntax: .bank BYTE

        The .bank directive sets the ROM bank being assembled to. The BYTE
        value, which must be from 0 to 255, sets the 8 high order bits of the
        address. This allows cftasm to assemble multi-bank code.
        """

        bank = self.parseField(tokens[2:], allbits=True)
        if bank < 0 or bank > 255:
            self.fail('bank should be in the range &00-&FF')
            
        self.bank = bank & 0xff
        # TODO: reinstate this after bank support is completed (and *if*)
        #self.pasm.write('\n\n.bank %02x\n\n' % self.bank)

        # Inhibit the next address increase.
        self.jumped = True


    def pushNamespace(self, line):
        """Enter a new namespace.

        Namespaces segregate symbols to avoid name polution and allow
        semi-private symbols to be defined.
        """
        try:
            name = re.findall('^\.pushns\s+(\w+)\s*', line)[0]
        except (TypeError, IndexError):
            self.fail('syntax error parsing .pushns')

        self.ns.append(name)


        
    def popNamespace(self, line):
        """Leave the last namespace.
        """
        try:
            assert re.findall('^(\.popns)\s*', line)[0] != ''
        except (TypeError, IndexError):
            self.fail('syntax error parsing .popns')

        if len(self.ns) == 0:
            self.fail('namespace/scope stack already empty!')

        self.ns = self.ns[:-1]


    def startScope(self, line):
        """Start a new scope.
        """
        self.scope += 1
        self.pushNamespace('.pushns _s%d' % self.scope)
    

    def endScope(self, line):
        """End the last scope.
        """
        self.popNamespace('.popns')
        # if len(self.scope) > 0:
        #     for sym in self.scope.pop():
        #         try:
        #             print "Deleting scope-local symbol %s" % sym
        #             del self.symbols[sym]
        #         except KeyError:
        #             continue
        # else:
        #     self.fail('.endscope without matching .scope.')
        
    def assembleInstruction(self, tokens, orgline):
        """Assemble a single instruction.

        The output is XORred with 0x400, the R flag, which is active LOW in the
        machine. This is to simplify assembly by ORring values (obviously: you
        can't turn 1 into 0 through OR).
        """
        self.jumped = False
        # Only assemble if we're on the assembly pass.
        if self.passnum == self.PSN_ASSEMBLY:
            # This will raise appropriate exceptions.

            # Alexios (2012-01-23) the R flag has reversed semantics in
            # microcode version 4, so we no longer need to toggle it. Code will
            # work as expected now.
            val = self.parseField(tokens) # ^ self.R_FLAG
            self.poke(val, poketype='I')
            self.logasm(val, orgline=orgline)


    def lexer(self, line):
        r"""Tokenise a line.

        >>> x = CFTAssembler()
        >>> list(x.lexer('foo bar'))
        ['foo', 'bar']
        >>> list(x.lexer('foo bar "baz"'))
        ['foo', 'bar', '"baz"']
        >>> list(x.lexer('foo bar "baz;\\n" ; a test'))
        ['foo', 'bar', '"baz;\n"']
        """
        buf = list()
        inquote = False
        esc = False
        for char in line.strip():
            if not inquote:
                if char == '"':
                    if buf:
                        yield str(''.join(buf))
                    inquote = True
                    buf = [char]
                    continue
                elif char in ';/':
                    if buf:
                        yield str(''.join(buf))
                    buf = list()
                    break
                elif char in ':[]()':
                    if buf:
                        yield str(''.join(buf))
                    yield char
                    buf = list()
                    continue
                elif char in "\t ":
                    if buf:
                        yield str(''.join(buf))
                    buf = list()
                    continue
                else:
                    buf.append(char)

            if inquote:
                if not esc:
                    if char == '\\':
                        esc = True
                        continue
                    elif char == '"':
                        buf.append(char)
                        inquote = False
                        yield str(''.join(buf))
                        buf = list()
                        continue
                    else:
                        buf.append(char)
                else:
                    if char == 'n':
                        buf.append('\n')
                    elif char == 't':
                        buf.append('\t')
                    elif char == 'b':
                        buf.append('\b')
                    elif char == '\\':
                        buf.append('\\')
                    elif char == '"':
                        buf.append('"')
                    esc = False

        if buf:
            yield str(''.join(buf))

        
    def parseInt(self, x):
        """Parse an integer.
    
        Base Conventions:
    
        * default base: 16 (e.g. fffe, 0001).
        * base 10: # (e.g. #32 == 20)
        * base 2: : (e.g. :1111 == f). 1 = '1', zero = any of 0, -, ., _.
          Useful for building human-readable bitfields.

        >>> x = CFTAssembler()
        >>> x.parseInt('&10')
        16
        >>> x.parseInt('&fffe')
        65534
        >>> x.parseInt('16')
        16
        >>> x.parseInt(':10000')
        16
        >>> x.parseInt(':1____')
        16
        >>> x.parseInt(':1....')
        16
        >>> x.parseInt(':1----')
        16
        >>> x.parseInt('foobar')
        Traceback (most recent call last):
        ValueError: unable to parse literal 'foobar'
        """
        if x.startswith('#'):
            x = x[1:]
            for zero in "-_.":
                x = x.replace(zero, '0')
            for zero in "',":
                x = x.replace(zero, '')
            return int(x, 2)
        elif x.startswith('&'):
            return int(x[1:], 16)
        elif x.startswith('0x'):
            return int(x[2:], 16)
        else:
            try:
                return int(x) & 0xffff
            except:
                raise ValueError("unable to parse literal '%s'" % x)


    def parseToken(self, x, pageboundary=True):
        """Parse a lexical token, be it literal or symbolic.

        >>> x = CFTAssembler()
        >>> x.addSymbol('spam', 42)
        >>> x.addSymbol('eggs', 65535)
        >>> x.parseToken('spam')
        42
        >>> x.parseToken('eggs')
        65535
        >>> x.parseToken('&1000')
        4096
        >>> x.parseToken('#1000')
        1000
        >>> x.parseToken(':1000')
        8
        >>> x.addr = 32
        >>> x.parseToken('@-10')
        22
        >>> x.parseToken('@-&10')
        16
        >>> x.parseToken('@+&10')
        48
        """
        # Is it a bracket-like convenience symbol? Note that, just like the
        # PAL-8 assembler, we do NOT check for balanced parentheses!
        #if x in '()':
        #    return self.R_FLAG
        #elif x in '[]':
        #    return self.I_FLAG
            
        # Is it in the symbol table?
        try:
            return self.getSymbol(x)
        except KeyError:
            if re.match('^[A-Za-z]', x):
                #print "Failed to look up", x
                # An undefined symbol was used during the macro or symbol
                # discovery passes. Defer this symbol for another pass.
                #if x not in self.deferred:
                #    self.deferred.append(x)
                #    print "Pass %d: deferring resolution of symbol '%s'" % (self.passnum, x)
                if self.passnum == self.PSN_ASSEMBLY:
                    self.fail("Unknown symbol '%s'." % x)
                return 0xdead

            try:
                # Does it start with a '@'? If so, check relative
                # references, making sure they reference an address on
                # the same page as the current one.
                if x == '@':
                    return self.addr
                elif x.startswith('@-'):
                    addr = (self.addr - self.parseInt(x[2:])) & 0xffff
                    if pageboundary:
                        if (addr & 0xfc00) != (self.addr & 0xfc00):
                            self.fail("relative reference '%s' (%04x) crosses page boundary." % (x, addr))
                    return addr
                elif x.startswith('@+'):
                    addr = (self.addr + self.parseInt(x[2:])) & 0xffff
                    if pageboundary:
                        if (addr & 0xfc00) != (self.addr & 0xfc00):
                            self.fail("relative reference '%s' (%04x) crosses page boundary." % (x, addr))
                    return addr
                elif x.startswith('@'):
                    # Attempt to parse @<token><op><token> syntax.
                    try:
                        left, op, right = re.findall('^@(.+?)([+*/&|^-]|<<|>>)(.+)$', x)[0]
                        left = self.parseToken(left)
                        right = self.parseToken(right)
                    except IndexError:
                        self.fail("unable to parse relative address '%s'." % x)

                    try:
                        left = left.val
                    except AttributeError:
                        pass
                    try:
                        right = right.val
                    except AttributeError:
                        pass
                    
                    try:
                        val = {
                            '+': lambda a, b: a + b,
                            '-': lambda a, b: a - b,
                            '|': lambda a, b: a | b,
                            '&': lambda a, b: a & b,
                            '*': lambda a, b: a * b,
                            '/': lambda a, b: a // b,
                            '^': lambda a, b: a ^ b,
                            '<<': lambda a, b: a << b,
                            '>>': lambda a, b: a >> b,
                            }[op](left, right) & 0xffff
                        
                        val = eval('%s %s %s' % (left, op, right)) & 0xffff
                    except:
                        self.fail("Failed to parse relative expression '%s'." % x)
                    #self.fail("TEST: (%s) (%s) (%s) => %d" % (left, op, right, val))
                    return val
                else:
                    return self.parseInt(x)
            except ValueError:
                self.fail("unable to parse literal value '%s'." % x)


    def parseField(self, tokens, allbits=False, pageboundary=True):
        """Parse a whole field of tokens.

        Works by parsing each token into an integer, and ORring all integers
        together.

        >>> x = CFTAssembler()
        >>> x.addSymbol('spam', 0xef)
        >>> x.addSymbol('eggs', 0xbe00)
        >>> hex(x.parseField('spam eggs'))
        '0xbeef'
        >>> hex(x.parseField('eggs :101'))
        '0xbe05'
        >>> hex(x.parseField('&be00 #4 :1'))
        '0xbe05'
        >>> hex(x.parseField('foo'))
        Traceback (most recent call last):
        ValueError: unable to parse literal 'foo'
        """
        if hasattr(tokens, 'split'):
            tokens = tokens.split()
        res = 0
        for token in tokens:
            val = self.parseToken(token, pageboundary=pageboundary)
            if val is None:
                return None
            try:
                #res |= val
                if allbits:
                    res |= val
                else:
                    res |= (val & 0x03ff)

            except TypeError:
                if allbits:
                    res |= val.val

                else:
                    # Check if the symbol referenced is accessible
                    relto = self.addr & 0xfc00
                    if res & self.R_FLAG:
                        relto = 0
                    if val.inaccessible(relto):
                        self.warn("%s '%s' on page %04x, but page %04x accessed instead." %
                                  (val.__class__.__name__, token,
                                   val.page, relto))
                    res |= val.assembly_val
        return res


    def outsym(self):
        """Print out the symbol table."""
        # Open the symbol output file.
        out = open(self.symbol_file, 'w')
        
        maxnamelength = max(len(x) for x in list(self.symbols.keys()))
        
        fmt = "%%-%ds  %%04x  %%-6s  %%s:%%d\n" % maxnamelength
        hdr = "%%-%ds  %%-4s  %%-6s  %%s\n" % maxnamelength
        header = hdr % ('Name', 'Val', 'Type', 'Defined in')

        out.write(header + ('-' * 79) + '\n')
        for sym in sorted(list(self.symbols.values()), key=lambda x: (x.filename, x.linenum)):
            out.write(fmt % (sym.name, sym.val,
                             sym.__class__.__name__.lower(),
                             sym.filename, sym.linenum))

        # Close it, just in case.
        out.close()
            

    def outmap(self):
        """Print out the map file."""
        # Open the map output file.
        out = open(self.map_file, 'w')

        def mapcmp(a,b):
            return cmp(a.val, b.val) or cmp(a.filename, b.filename) or \
                cmp(a.linenum, b.linenum) or cmp(a.name, b.name)

        labels = [ x for x in list(self.symbols.values()) if isinstance(x, Label) ]
        if not labels:
            out.write('nothing  0000  <none>:0')
            return

        fmt = '%%-%ds  %%04x  %%s:%%d\n' % max(len(x.name) for x in labels)

        for sym in sorted(labels, key=lambda x: (x.val, x.filename, x.linenum, x.name)):
            out.write(fmt % (sym.name, sym.val, sym.filename, sym.linenum))

        # Close it, just in case.
        out.close()
            

    def outxpm(self):
        """Print out the xpm map file."""
        # Open the map output file.
        if not self.opts.xpm:
            return

        out = open(self.xpm_map_file, 'w')
        out.write(XPMHEAD)

        for ofs in range(0, 65536, 256):
            out.write(',\n"%s"' % ''.join(chr(self.sentinel[ofs:ofs+256])))

        out.write(XPMFOOT)

        # Close it, just in case.
        out.close()
            

    def getSymbol(self, sym):
        """Return the value of a symbol from the symbol table. Raise KeyError
        if it doesn't exist."""

        if re.match('^[@#&0-9]', sym):
            raise KeyError

        #print "Looking up", sym
        if re.match('^[^a-zA-Z_]', sym):
            raise KeyError             # It's a literal, not a symbol

        for x in range(len(self.ns), -1, -1):
            try:
                nssym = '.'.join(self.ns[0:x] + [sym])
                #print "Pass", self.passnum, ", Looking up", nssym, self.ns
                return self.symbols[nssym]
            except KeyError:
                continue
        # Failed to find it.
        raise KeyError
            

    def getMacro(self, name):
        """Return the value of a macro from the macro table. Raise KeyError
        if it doesn't exist."""

        #print "Looking up macro", name
        for x in range(len(self.ns), -1, -1):
            try:
                nsname = '.'.join(self.ns[0:x] + [name])
                #print "Pass", self.passnum, ", Looking up", nsname, self.ns
                return self.macros[nsname]
            except KeyError:
                continue
        # Failed to find it.
        raise KeyError
            

    def addSymbol(self, sym, val, symtype=None):
        """Add a symbol to the symbol table.

        >>> x = CFTAssembler()
        >>> x.addSymbol('spam', 42)
        >>> x.addSymbol('spam', 43)
        <none>:1:warning: redefining symbol spam (#42) to different value (#43).
        """
        # Prefix the symbol with all namespaces
        sym0 = sym
        sym = '.'.join(self.ns + [sym])
        
        # Add local symbols to the current scope, if necessary
        #if sym0.startswith('_') and len(self.scope) > 0:
        #    self.scope[-1].append(sym)

        #print "File", self.filename, "Pass", self.passnum, ", adding symbol", sym

        # TODO: issue a warning if redefining a symbol.
        if sym in self.symbols:
            old = self.symbols[sym]
            if val != old.val and self.passnum == self.PSN_SYMBOL_DISCOVERY \
                    and (old.filename, old.linenum) != (self.filename, self.linenum):
                self.warn('redefining symbol %s (#%d) to different value (#%d).' % \
                              (sym, old.val, val))
                self.warn('previous declaration of %s in file %s line %d.' % \
                              (sym, old.filename, old.linenum))
        cls = symtype or Symbol
        if self.opts.debugging:
            sys.stderr.write('D: %s:%d: %04x addSymbol %s = %d, type=%s\n' % \
                                 (self.filename, self.linenum, self.addr, sym, val, str(cls)))
        self.symbols[sym] = cls(sym, val, self.filename, self.linenum)

        
    def mkaddr21(self, addr):
        """Make a full 21-bit physical address based on the current bank and an
        address, or return just the address."""
        if self.opts.banked:
            return ((self.bank << 13) + (addr & 0x1fff)) & 0x1fffff
        return addr & 0xffff


    def mkaddr24(self, addr):
        """Make a full 24-bit physical address based on the current bank and an
        address, or return just the address."""
        if self.opts.banked:
            return (((self.bank & 0xff) << 16) + (addr & 0xffff)) & 0xffffff
        return addr & 0xffff


    def poke(self, val, addr=None, poketype="?"):
        """Store an address in the memory image. The optional address may be
        used to override the current address."""
        self.jumped = False
        addr = addr or self.addr

        if poketype not in 'R' and self.opts.banked and self.bank is None:
            self.fail("assembling code before setting a bank (use .bank XX).")

        # Sanity check.
        if poketype == 'I':
            if (addr < self.opts.min_addr) and not self.boundwarn_low:
                self.boundwarn_low = True
                self.warn('Assembling code at address %06x, object file contains %06x-%06x' % \
                              (addr, self.opts.min_addr, self.opts.max_addr))
            elif (addr > self.opts.max_addr) and not self.boundwarn_high:
                self.boundwarn_high = True
                self.warn('Assembling code at address %06x, object file contains %06x-%06x' % \
                              (addr, self.opts.min_addr, self.opts.max_addr))

        self.minaddr = min(self.minaddr, self.addr)
        self.maxaddr = max(self.maxaddr, self.addr)

        try:
            poketype = chr(poketype)
        except:
            pass

        #if self.passnum == self.PSN_ASSEMBLY:
        #    if self.sentinel[addr] != '\0':
        #        datatype = {
        #            'I': 'instruction',
        #            'W': '.word',
        #            'S': 'string',
        #            'F': '.fill',
        #            }.get(self.sentinel[addr], '(unknown type)')
        #        self.warn('Code at address %04x overrides previous %s data.' %
        #                  (addr, datatype))

        self.mem[self.mkaddr24(addr or self.addr)] = val & 0xffff
        self.sentinel[self.mkaddr24(addr)] = ord(poketype)


    def setaddr(self, a):
        """Set the address."""
        self.addr = a & 0xffff
        self.jumped = True
        self.wrap = False


    def incaddr(self, by=1):
        """Increment the address."""
        # If the address has just been set and no data has been written to
        # memory, don't increment yet.
        if self.jumped:
            #print "JUMPED"
            return

        self.addr = (self.addr + by) & 0xffff
        if self.addr == 0:
            self.wrap = True
        elif self.wrap and self.addr == 1:
            # Warn the second time this gets here to avoid a spurious
            # warning when 0xffff is written to (and no further).
            self.wrap = False
            self.warn('64KW bank boundary crossed.')


    def yieldmem(self):
        """Yield each word of memory (in the range specified on the
        command line) as an (addr, data) tuple."""
        a0 = self.opts.min_addr
        a1 = self.opts.max_addr + 1
        for addr in range(a0, a1):
            yield (addr, self.mem[self.mkaddr24(addr)])


    def outobj(self):
        """Write object code."""
        a0 = self.opts.min_addr
        a1 = self.opts.max_addr + 1
        self.mem[a0:a1].tofile(open(self.opts.out_file, 'wb'))

        # In this version, we always output Verilog files.
        if True or self.opts.verilog:
            # Also write two Verilog ROM images (low and high half-words)
            basename = os.path.splitext(self.opts.out_file)[0]
            lo = open('%s-00.list' % basename, 'wt')
            hi = open('%s-01.list' % basename, 'wt')
            if self.opts.verbose:
                for addr, val in self.yieldmem():
                    lo.write("%s\t// %04x: %04x\n" % (bin(val & 0xff)[2:].zfill(8), addr, val))
                    hi.write("%s\t// %04x: %04x\n" % (bin((val >> 8) & 0xff)[2:].zfill(8), addr, val))
            else:
                for addr, val in self.yieldmem():
                    lo.write(bin(val & 0xff)[2:].zfill(8) + '\n')
                    hi.write(bin((val >> 8) & 0xff)[2:].zfill(8) + '\n')

            lo.close()
            hi.close()


    def logasm(self, val, msg=None, orgline=None):
        """Logs an assembly message.

        Assembly messages log the entire program
        in a format that is human-readable but may be parsed by both the
        assembler and other machine tools.

        If val is None, then no machine-code value is dumped for this
        line. This is used to log multi-word directives etc.
        """
        if val is not None and msg is not None:
            raise ValueError('Exactly one of val, msg may be set.')

        msg = msg or ''
        if orgline:
            orgline = ' ; ' + orgline
        else:
            orgline = ''

        if self.opts.banked:
            fmt = "&{:>06x}:"
        else:
            fmt = "&{:>04x}:"
            
        if val is None:
            line = (fmt + "      {}{}\n").format(self.addr, msg, orgline)
        else:
            line = (fmt + " &{:>04x}{}\n").format(self.addr, val, orgline)
        if self.opts.verbose:
            sys.stdout.write(line)
        self.pasm.write(line)


    def _msg(self, msg, filename=None, linenum=None):
        """Output a message, along with file and line number info."""
        sys.stderr.write('%s:%d:%s\n' % (filename or self.filename,
                                         linenum or self.linenum,
                                         msg))


    def warn(self, msg):
        """Output a warning message."""
        self._msg('warning: ' + msg)


    def fail(self, msg):
        """Output an error message and fail."""
        # Is there a macro context we should print out?
        for (n, f, ln, mdef) in self.ctx:
            if mdef:
                self._msg("error: (in macro '%s' invocation)" % n,
                          filename=f, linenum=ln-1)
            else:
                self._msg("error: (included from %s on line %d)" % (f, ln),
                          filename=f, linenum=ln)

        self._msg('error: ' + msg)
        sys.exit(1)


    def die(self, msg):
        """Output an interal, fatal error and fail."""
        sys.stderr.write('%s: %s\n' % (sys.argv[0], msg))
        sys.exit(1)
            

CFTAssembler()

# End of file.
